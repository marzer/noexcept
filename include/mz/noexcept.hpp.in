//----------------------------------------------------------------------------------------------------------------------
//
// {% namespaces::main %}::noexcept
// https://github.com/marzer/noexcept
// SPDX-License-Identifier: MIT
//
//----------------------------------------------------------------------------------------------------------------------
//% generated_header_preamble
//----------------------------------------------------------------------------------------------------------------------
#ifndef {% macros::prefix %}NOEXCEPT_HPP
#define {% macros::prefix %}NOEXCEPT_HPP

#define {% macros::prefix %}NOEXCEPT_VERSION_MAJOR 1
#define {% macros::prefix %}NOEXCEPT_VERSION_MINOR 0
#define {% macros::prefix %}NOEXCEPT_VERSION_PATCH 0

//% preprocessor::arch::amd64
//% preprocessor::arch::arm

#include <type_traits>

namespace {% namespaces::main %}
{
	// --------- base templates -------------------------------------------------

	template <typename T>
	struct add_noexcept
	{
		using type = T;
	};

	template <typename T>
	using add_noexcept_t = typename add_noexcept<T>::type;

	template <typename T>
	struct remove_noexcept
	{
		using type = T;
	};

	template <typename T>
	using remove_noexcept_t = typename remove_noexcept<T>::type;

	template <typename T>
	struct is_noexcept : std::bool_constant<!std::is_same<remove_noexcept_t<T>, T>::value>
	{};

	template <typename T>
	inline constexpr bool is_noexcept_v = is_noexcept<T>::value;

	// --------- pointer and cvref permutations -------------------------------------------------

	template <typename T>
	struct add_noexcept<T*>
	{
		using type = typename add_noexcept<T>::type*;
	};

	template <typename T>
	struct remove_noexcept<T*>
	{
		using type = typename remove_noexcept<T>::type*;
	};

	template <typename T>
	struct add_noexcept<T&>
	{
		using type = typename add_noexcept<T>::type&;
	};

	template <typename T>
	struct remove_noexcept<T&>
	{
		using type = typename remove_noexcept<T>::type&;
	};

	template <typename T>
	struct add_noexcept<T&&>
	{
		using type = typename add_noexcept<T>::type&&;
	};

	template <typename T>
	struct remove_noexcept<T&&>
	{
		using type = typename remove_noexcept<T>::type&&;
	};

	template <typename T>
	struct add_noexcept<const T>
	{
		using type = const typename add_noexcept<T>::type;
	};

	template <typename T>
	struct remove_noexcept<const T>
	{
		using type = const typename remove_noexcept<T>::type;
	};

	template <typename T>
	struct add_noexcept<volatile T>
	{
		using type = volatile typename add_noexcept<T>::type;
	};

	template <typename T>
	struct remove_noexcept<volatile T>
	{
		using type = volatile typename remove_noexcept<T>::type;
	};

	template <typename T>
	struct add_noexcept<const volatile T>
	{
		using type = const volatile typename add_noexcept<T>::type;
	};

	template <typename T>
	struct remove_noexcept<const volatile T>
	{
		using type = const volatile typename remove_noexcept<T>::type;
	};

	// {{ autogenerated_traits }}
}

// {{ permutation_list }}

#endif // {% macros::prefix %}NOEXCEPT_HPP
